# Lecture0

## Solving Search Problem

Search Problem 要求我们解决一个在加权图上从 initial state 到 goal state 的寻求可行解或者最优解的问题。

对于这样的问题我们的算法往往存在一个通用的范式：

1. 如果我们当前已经到达的点的 frontier 集合不为空，我们找到其中一个frontier
2. 计算转移后的结果
3. 然后将这个点可能拓展到的状态放入frontier集合中

如果需要得到 path，我们可以通过记录 node 的丰富信息而使其可回溯而实现，这点并不困难

## uninformed

### DFS

我们现在的问题变成了用什么维护 frontier 的集合，很显然，不同的数据组织方式会得到不同的结果

不论是我们用数据栈还是系统栈实现都是呈现出一种Depth-First  Search 的状态

（可惜这在之前我并没有清晰地认识到）

### BFS

用队列组织会表现出一种 Breadth-First Search 的状态

## informed

上面的 DFS 和 BFS 都是两种 uninformed search，什么叫做 uninformed 呢？

因为他们的决策并不会由于图的性质而产生有效的决策变化，具体而言，对于随机图而言，两者都表现出很强的随机性

### Greedy Best-First Search

为了使得我们的搜索针对特定问题特定的图有基于信息的优化，我们提出了启发式搜索

启发式搜索的原理在于，我们对于每一个 state 进行估价。将这个估价函数（**heuristic function**）表示为 $h(state)$

我们期望通过估价函数去得到每一个状态的近似的优先级，然后每次从 frontier 里面取出的元素都是优先级最高的先进行操作

我们很容易发现，这个算法很依赖于估价函数的质量：不仅是估价函数的准度，也同样在于估价函数的时空复杂度

其中一种做法便是GBFS

这种做法把估价函数简单的定义为从这个点到终点的大致距离，例如对于棋盘问题，我们将其定义为当前 state 所在的点到终点的曼哈顿距离（**Manhattan distance**）

### A*

上面的GBFS好像已经比较完备了，但实际上还有致命的漏洞

简单来说，我们选择走到这个点，不仅仅因为从这个点走到终点的代价可能比较小，也因为我们从出发点走到这个点的代价也比较小

很显然GBFS只考虑了某个状态到终点的距离期望最短（可能这里用期望不是很合适，但是我想尽量强调很多时候我们是一种估计，因为我们如果可以很快准确得到一个估价，我们这个问题已经不需要搜索便解决了），但当我们两者都考虑的时候，我们就得到了A*算法

一般来说，A\*算法的估价函数包括两个部分：当前状态已经花费的代价，和估计的到达终点还要花费的代价。正因为如此，A\*看起来更加合理，同时在相比于 GBFS 增加了估价函数精度的同时，并没有增加所需要的时间复杂度

## Adversarial Search

除了单人策略的搜索，当然还存在双人的对抗搜索。在双人对抗当中，我们总是认定双方都是足够聪明的。虽然我们很难准确描述足够聪明，但是我们认为这种聪明是考虑所有情况的全局最优解

以井字棋为例，如果我们是足够聪明的，那么意味着我们可以在心中算无数步，并且准确知道我们下在哪里是最优的。

在井字棋中，“最优”由