# Lecture0

## Solving Search Problem

Search Problem 要求我们解决一个在加权图上从 initial state 到 goal state 的寻求可行解或者最优解的问题。

对于这样的问题我们的算法往往存在一个通用的范式：

1. 如果我们当前已经到达的点的 frontier 集合不为空，我们找到其中一个frontier
2. 计算转移后的结果
3. 然后将这个点可能拓展到的状态放入frontier集合中

如果需要得到 path，我们可以通过记录 node 的丰富信息而使其可回溯而实现，这点并不困难

## uninformed

### DFS

我们现在的问题变成了用什么维护 frontier 的集合，很显然，不同的数据组织方式会得到不同的结果

不论是我们用数据栈还是系统栈实现都是呈现出一种Depth-First  Search 的状态

（可惜这在之前我并没有清晰地认识到）

### BFS

用队列组织会表现出一种 Breadth-First Search 的状态

## informed

上面的 DFS 和 BFS 都是两种 uninformed search，什么叫做 uninformed 呢？

因为他们的决策并不会由于图的性质而产生有效的决策变化，具体而言，对于随机图而言，两者都表现出很强的随机性

### Greedy Best-First Search

为了使得我们的搜索针对特定问题特定的图有基于信息的优化，我们提出了启发式搜索

启发式搜索的原理在于，我们对于每一个 state 进行估价。将这个估价函数（**heuristic function**）表示为 $h(state)$

我们期望通过估价函数去得到每一个状态的近似的优先级，然后每次从 frontier 里面取出的元素都是优先级最高的先进行操作

我们很容易发现，这个算法很依赖于估价函数的质量：不仅是估价函数的准度，也同样在于估价函数的时空复杂度

其中一种做法便是GBFS

这种做法把估价函数简单的定义为从这个点到终点的大致距离，例如对于棋盘问题，我们将其定义为当前 state 所在的点到终点的曼哈顿距离（**Manhattan distance**）

### A*

上面的GBFS好像已经比较完备了，但实际上还有致命的漏洞

简单来说，我们选择走到这个点，不仅仅因为从这个点走到终点的代价可能比较小，也因为我们从出发点走到这个点的代价也比较小

很显然GBFS只考虑了某个状态到终点的距离期望最短（可能这里用期望不是很合适，但是我想尽量强调很多时候我们是一种估计，因为我们如果可以很快准确得到一个估价，我们这个问题已经不需要搜索便解决了），但当我们两者都考虑的时候，我们就得到了A*算法

一般来说，A\*算法的估价函数包括两个部分：当前状态已经花费的代价，和估计的到达终点还要花费的代价。正因为如此，A\*看起来更加合理，同时在相比于 GBFS 增加了估价函数精度的同时，并没有增加所需要的时间复杂度

## Adversarial Search

### Minimax

除了单人策略的搜索，当然还存在双人的对抗搜索。双人对抗指的是，一种双人轮流对对局产生影响的博弈。在双人对抗当中，我们总是认定双方都是足够聪明的。虽然我们很难准确描述足够聪明，但是我们认为这种聪明是考虑所有情况的全局最优解

以井字棋为例，如果我们是足够聪明的，那么意味着我们可以在心中算无数步，并且准确知道我们下在哪里是最优的。

在井字棋中，“最优”由是否输赢决定，我们可以对于先手方设定函数$f(x)$表示对于先手方而言，从这个状态在双方都足够聪明的情况下，这场游戏会输赢还是平手（我们可以用1来代表赢，-1代表输，0代表平手），其中$x$是状态

在这个时候你可能还是比较抽象，你想象不出这样的函数有什么性质，不妨我们画出一部分的状态及其之间的转移出来。到这个时候你应该会发现，我们所有的搜索都会产生一个搜索树，尽管是在一个图上的搜索，我们通过到达同一个点的时间不同，将其分为两个状态时，也能产生一个搜索树。我们最后想要得到的是$f(init)$的结果，因此不妨看看这个状态与其子状态的函数有什么关系

我们不难发现（虽然可能第一次看的时候是很难发现），父节点和子节点有一定关系，具体表现为：若我作为一方，选择某个状态后的函数，应该等于对方从这个状态出发所有操作得到的最好的状态的函数的值。这样很容易理解，由于我们认为对方是足够聪明的，所以对方会在我们操作的状态上选择自己操作过后收益最大的情况进行。对应我们的函数定义，正手方总是想要得到的函数尽量的大，所以总会从搜索树上选择收益最大的点转移，而后手方宗寺想要达到的函数尽量的小，所以总会从搜索树上选择收益最小的点转移。

具体而言，在生成的搜索树中，由于双方博弈是交错的，搜索树是分层的，先手的选择的结果基于后手所有可能选择中的$min$，同样的，后手的选择的结果基于先手所有可能选择中的$max$。

我们将这样的对抗策略的算法叫做Minimax，因为在这个算法中，我们总是在mins中找max，在maxs中找min。我们很容易发现，这样的算法要求我们把搜索树展开，所以无所谓我们采用怎样的数据结构组织frontier，我们都必定会把所有的节点搜索满，所以frontier组织这个方面不会影响效率。但是我们考虑到，我们总是需要让父亲节点获取子节点的信息，我们最理想的方式就是通过回溯的方式利用系统栈进行DFS。

具体的各种函数定义和组织方式详见课程视频

### Alpha-Beta Pruning

我们考虑到，由于我们父节点需要在子节点的信息中取得max，min，那是不是就是说我们必须访问所有的节点才能够得到结果呢？答案是否定的。

当我们考虑到一层关系的时候确实表现为我们必须知道所有的信息，但是我们考虑到多层关系的时候，我们会发现，我们的兄弟之间有这样的关系，假设我前面的兄弟已经算出来了，而我现在进行到一半的时候发现，我的兄弟的结果已经比我劣了，拿我的父亲必然即使选择我的兄弟，也不会选择我。那这个时候这个子树的搜索就不必进行下去了，之间跳到下一个子树即可。关于如何优雅的实现这个功能，我想也不需要多说了

