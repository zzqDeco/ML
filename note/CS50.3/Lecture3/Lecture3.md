# Optimization

## optimization

choosing the best option from a set of options.

## local search

不同于之前谈到的bfs，dfs，a*算法，local search更注重于得到我们目标的位置，而不在乎我们的路径

对于这样的搜索，我们拥有state-space landscape这样的东西，这是一个关于我们目前状态的一个函数，我们的目的就变成了在这样的函数上找到一个最值，这不同于我们之前的搜索，我们想要找到的是一个路径，一个解决问题的方式，我们现在只需要一个答案。

即便我们不需要找到一个路径，但我们依然是需要经历一个过程来靠近这个想要的目标。我们定义这样的东西，叫做neighbor，就是两个相邻的状态。这个neighbor的定义是基于你的想法的，这个定义只在于让你专注于neighbor之间状态的关系

我们在这里讨论的搜索，包含了，起始点选择，优化，找到最优答案。

## hill climbing

经典爬山算法，在自己neighbor中比较，往高处走。如果我现在的state不如我的neighbor，那我就搬到我的neighbor那里去。缺点很明显，很有可能陷入局部最优解。

有很多爬山的变种，但是都不能很稳定（很不稳定）的保证脱离极值。

## Simulated Annealing

模拟退火的基本思想就是，让开始时状态保持一个高温的活跃的转移，然后逐渐减低转移的温度，使得转移趋于稳定。

具体而言，我们在一开始时拥有较大的转移半径，在这个半径内随机选点进行转移。较大的转移半径体现在较大的概率接受差解，这很好理解。随后这个转移半径会逐渐缩小。

可以看出这是针对于爬山（具体而言是针对接受差解的爬山）的改进，在这个过程中添加了退火的温度概念，使得有更多选择

可以看出，对于模拟退火，我们的概率函数的定义直接影响到效果和效率。对于概率函数有这样的一般选择：$e^{\Delta{E}/T}$ ，参数分别是状态增量和时间函数

### Quiz

一个简单的例子就是旅行商问题，这是一个很经典的np问题，这意味着它不具有polylog的做法，我们用模拟退火来找到其可能最优解

在这个问题中我们起始点的选择是任意的一个回路，我们需要定义我们的邻居是什么以便我们转移。（在这个问题中，我们很难把离散的可行方案与数域对应，所以我们很难画出一个标准的函数，事实上也没必要，我们只需要知道如何转移状态，如何定义状态的优劣就完事了，也就是找到neighbor的定义就完事了，有些时候抓住事物的本质更重要）

在这个问题中一个常见的neighbor的定义是进行两边对应点交换过后的回路定义为neighbor。这样形成的状态就是成图状的

## Linear Programming

Linear Programming是指对于一个线性的方程进行最大值最小值求解，在这个过程中会涉及到有各种各样的约束：

1. 某个线性方程或者线性不等式成立
2. 某个变量有范围限制

实际上这就是中文上的线性规划，我们想要找到一个空间上的使得cost函数取到最值的点

这可能和
