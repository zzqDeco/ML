# Optimization

## optimization

choosing the best option from a set of options.

## local search

不同于之前谈到的bfs，dfs，a*算法，local search更注重于得到我们目标的位置，而不在乎我们的路径

对于这样的搜索，我们拥有state-space landscape这样的东西，这是一个关于我们目前状态的一个函数，我们的目的就变成了在这样的函数上找到一个最值，这不同于我们之前的搜索，我们想要找到的是一个路径，一个解决问题的方式，我们现在只需要一个答案。

即便我们不需要找到一个路径，但我们依然是需要经历一个过程来靠近这个想要的目标。我们定义这样的东西，叫做neighbor，就是两个相邻的状态。这个neighbor的定义是基于你的想法的，这个定义只在于让你专注于neighbor之间状态的关系

我们在这里讨论的搜索，包含了，起始点选择，优化，找到最优答案。

## hill climbing

经典爬山算法，在自己neighbor中比较，往高处走。如果我现在的state不如我的neighbor，那我就搬到我的neighbor那里去。缺点很明显，很有可能陷入局部最优解。

有很多爬山的变种，但是都不能很稳定（很不稳定）的保证脱离极值。

## Simulated Annealing

模拟退火的基本思想就是，让开始时状态保持一个高温的活跃的转移，然后逐渐减低转移的温度，使得转移趋于稳定。

具体而言，我们在一开始时拥有较大的转移半径，在这个半径内随机选点进行转移。较大的转移半径体现在较大的概率接受差解，这很好理解。随后这个转移半径会逐渐缩小。

可以看出这是针对于爬山（具体而言是针对接受差解的爬山）的改进，在这个过程中添加了退火的温度概念，使得有更多选择

可以看出，对于模拟退火，我们的概率函数的定义直接影响到效果和效率。对于概率函数有这样的一般选择：$e^{\Delta{E}/T}$ ，参数分别是状态增量和时间函数

### Quiz

一个简单的例子就是旅行商问题，这是一个很经典的np问题，这意味着它不具有polylog的做法，我们用模拟退火来找到其可能最优解

在这个问题中我们起始点的选择是任意的一个回路，我们需要定义我们的邻居是什么以便我们转移。（在这个问题中，我们很难把离散的可行方案与数域对应，所以我们很难画出一个标准的函数，事实上也没必要，我们只需要知道如何转移状态，如何定义状态的优劣就完事了，也就是找到neighbor的定义就完事了，有些时候抓住事物的本质更重要）

在这个问题中一个常见的neighbor的定义是进行两边对应点交换过后的回路定义为neighbor。这样形成的状态就是成图状的

## Linear Programming

Linear Programming是指对于一个线性的方程进行最大值最小值求解，在这个过程中会涉及到有各种各样的约束：

1. 某个线性方程或者线性不等式成立
2. 某个变量有范围限制

实际上这就是中文上的线性规划，我们想要找到一个空间上的使得cost函数取到最值的点

这可能和我们上一个问题看起来的目标是差不多的，我们不需要知道我们如何找到这个最优点，我们只在乎这个最优点是什么。但是也有很多不同的地方，比如在上一个问题中我们更多讨论的是离散的问题，我们要求有neighbor这样的定义，这个定义是离散意义上的。但是我们现在的问题变成了连续空间上的问题，这样的问题有连续的性质，更甚之，我们有线性的性质，这将与我们的线性代数联系起来。

常见的两类算法是：

1. Simplex
2. Interior-Point

## Constraint Satisfaction

在这个问题中，我们讨论的是另一种约束下的最优化。在这个问题中，我们需要在互斥条件下分组，分组后要求互斥条件生效的数量最少。

这样讲可能有点抽象，我们可以具体举一个例子，有5个同学，每个同学有3门课程，一共有七门课程（这意味着存在有同学选学相同的课程），我们需要安排考试，使得所有同学考试都不在同一时间有两门，或者尽可能减少在同一时间考试冲突的情况数。实际上这个问题可以转化为对于图上的点分组，每条边相连的两个点的分组都不同，或者使得边关系满足最多的分组方法。

我们对于这个问题进行进一步的抽象，我们有很多的点，每个点有多个可选择的取值，我们有很多的点的边，用于约束点之间的取值不同，这就是我们要解决的问题。这样的问题实际上就是一个图意义上的数独。

我在上述表达中运用了很多的或者，这意味着，我们在这个过程中有两类的约束，分别是hard和soft。hard是指，这样的约束必须满足，不满足则无解，而soft是指这样的约束是不一定满足的，soft应该给hard让路。简单而言，hard规定的是正确还是错误，soft规定的是好坏。

我们再来考虑一下约束条件的类型，一般而言在这个问题中我们有两类，一类是一元约束，一类是二元约束。一元约束要求一个点的取值有限制，二元约束要求两个点的取值不同。

我们想办法满足这两类约束，第一类约束我们只需要直接删除某个节点的可选项，第二类约束我们可以进行一个简单的松弛，如何x选择某个值会使得他的邻居y无值可选，那么就直接删除x这个可选项，然后我们进行一个逐渐松弛操作使得整个网络都满足（很类似于spfa的松弛）。这个算法叫做AC-3

然而这个问题只是解决了不合法点的选取，并没有解决给出具体的优秀方案，得出方案按照一些常见np做法就行了（例如模拟退火，启发式搜索）
